# Android开发应该知道的HTTPS相关知识

### 前言

越来越多的网站和APP将请求协议从HTTP转换到了HTTPS，那么作为安卓程序员我们也有必要了解下HTTPS，不过本篇文章并不想讲太多难懂的理论，更多的是讲述HTTPS是如何实现数据加密并且身份验证的，除此之外还有个额外补充是关于Charles这类截包软件如何截取HTTPS消息的。

在开始之前如果你对对称加密、非对称加密、电子证书还、根证书、CA机构还不太了解的先看下下面的文章，这两篇是我看过讲的非常好的了，后面对这些概念不在细述。

[[白话解释 对称加密算法 VS 非对称加密算法]](https://segmentfault.com/a/1190000004461428)

[[白话解释 电子签名，电子证书，根证书，HTTPS，PKI 到底是什么]](https://segmentfault.com/a/1190000012466003)



### 概述

今天来聊聊我们工作中经常出现的HTTPS，首先抛出一个问题，在之前的工作中我们一直用的HTTP协议进行网络请求完全ok呀，那么我们为什么要用HTTPS呢？

很显然HTTP肯定有某些缺陷，这里我列出来。

1. 明文通信，信息会被窃听
2. 无法验证通信者身份
3. 无法保证信息未被篡改

那么换成HTTPS就一定是为了解决这些问题。但其实呢HTTPS通信和HTTP基本相同只不过在HTTP基础上加了一个SSL(Secure Socket Layer)协议帮我们解决了上述三个问题。

![](http://rocketzly.androider.top/https%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

从图上可以发现HTTPS其实就是身披SSL协议这层外壳的HTTP，在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。



### HTTPS流程分析

在我们准备和后台进行HTTPS交互前首先有两个准备工作

1. 服务端去CA机构申请，然后CA会给后端一对公钥、私钥和公钥证书，这个证书是CA通过他的私钥将服务端公钥、域名、公司名称等信息加密生成，最后后端将证书装在服务器上，当客户端通过HTTPS请求的时候返回给客户端。
2. 客户端（手机或者PC浏览器）上提前预装了CA的公钥，称为根证书，可以用来解密服务端返回的证书拿到当中的信息（最重要的两个验证域名和拿到公钥）。

这里我们可以看下CSDN的HTTPS证书

![](http://rocketzly.androider.top/CSDN%E6%A0%B9%E8%AF%81%E4%B9%A6%E5%9F%9F%E5%90%8D.png)

![](http://rocketzly.androider.top/CSDN%E6%A0%B9%E8%AF%81%E4%B9%A6%E5%AF%86%E9%92%A5.png)

可以看到拖动条非常长包含了非常多的信息，其中有两个非常重要的域名和公钥接下来我们会说到。

准备工作做完了接下来是流程的分析，看看HTTPS究竟如何做到数据加密、身份验证。

![](http://rocketzly.androider.top/HTTPS%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png)

1. 客户端先告诉服务端客户端支持的SSL版本信息等等。
2. 服务端告诉客户端使用的SSL版本、加密组件等信息。
3. **服务端将服务器上的证书返回给客户端。**
4. 告诉客户端SSL初次握手协商部分结束。
5. **然后客户端根据预装的根证书解密服务端传来的证书，这个过程中有两个非常重要的事要做1.确认你访问的域名是证书中支持的域名（验证身份）2.拿到证书当中的公钥。由于非对称加密比较消耗性能所以接下来会转为对称加密交换数据，但是对称加密最大的问题就是密钥传输过程不安全会被窃听，所以用这个公钥加密客户端生成的对称加密密钥传递给服务端（加密）。**
6. 告知服务端在后面的通信会采用第五步传递的密钥对称加密。
7. 发送finish报文，该报文包含连接至今全部报文的整体校验值（有了校验值保证数据不被篡改），并且是通过对称加密后传递给服务端。
8. 服务端发送和第六步类似的修改加密说明的报文。
9. 服务端发送和第七步类似的finish报文。
10. SSL通道建立成功后，后面的请求就都受SSL保护，接下来就是客户端通过HTTP协议发送请求。
11. 服务端返回HTTP请求响应。

接下来说下HTTPS前面提到的加密、身份认证和完整性保护在这个流程中是如何体现的。

- 加密：首先第三步传递给客户端的证书，即使被别人截获虽然能通过CA公钥查看里面的内容但是无法修改，因为你没有CA私钥去重新生成证书，假如你修改后通过自己的私钥生成一个伪证书给客户端，但是客户端并没预装对应的根证书无法解密所以证书是无法伪造的，其次在第五步传递对称加密密钥是通过服务端公钥加密传输的即使被截获也是在有限时间无法破解的，在后面SSL通道建立成功后，通过http传输的消息也会在SSL层对称加密后再传输。
- 身份验证：为了保证我们访问的服务端就是真正的服务端，所以在第五步证书解密的时候会确认你访问的域名是证书中支持的域名，比如上面CSDN证书中域名是*.csdn.net，那么如果客户端访问的域名不在该泛域名之内就会提示错误。
- 完整性：则是在请求的时候会把数据通过类似Hash算法这种签名算法生成一个摘要然后通过加密生成一个数字签名，将数字签名和加密后的报文一起传递给服务端，服务端拿到数据后先解密，然后通过同样的签名算法生成的摘要与请求体中的摘要比对，如果不一致则数据被篡改了。

最后总结下

**其实这个过程中最关键的就是服务端把证书返回给客户端，然后客户端验证身份、拿到公钥，再将客户端生成的对称加密密钥通过公钥加密传递给服务端，服务端通过私钥解析拿到对称加密密钥。后面的通信就是走的HTTP协议，只不过是通过这个密钥对称加密的。**



### Charles截取HTTPS报文

上面不是说道HTTPS是加密，那么Charles是如何截取HTTPS报文的呢？接下来我们就来分析。

首先Charles是支持SSL协议的，然后在截HTTPS报文之前，我们需要在手机上预装一个Charles的根证书，并且信任他（这一步非常关键后面细说）

准备工作做完了接下来是流程分析。

![](http://rocketzly.androider.top/Charles%E6%B5%81%E7%A8%8B.png)

流程用画板画的可能比较low(#^.^#)

上面HTTPS流程已经细讲过了，这里只讲重点流程了

1. 客户端告知服务端SSL版本等信息
2. 服务端返回证书给客户端
3. 然后charles通过CA根证书解密证书，复制一份并修改公钥，然后通过自己的私钥加密生成一个伪证书传递给客户端
4. 客户端从本地查找可以用来解密的根证书，由于我们之前在手机上预装了一个Charles根证书，所以可以解密传递过来的伪证书，拿到当中的charles公钥
5. 客户端生成对称加密密钥，通过Charles公钥加密传输
6. Charles通过自己的私钥解密拿到对称加密密钥，然后在通过服务端的公钥加密传递给服务端

这第六步走完后Charles已经拿到了对称加密密钥，那么后面对称加密的通信对于Charles来说也就等同于明文了，所以也就达到了HTTPS截包的目的。

现在再来看看我们一开始说的关键一步：在手机上预装Charles的根证书，如果没有那一步Charles生成的伪证书，客户端就没法解密，那么整个流程也就走不通，所以知道为什么关键了吧。



